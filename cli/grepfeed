#!/usr/bin/env node
/*
  filter by:

  -d [-]date[,date]
  -c categories

  by default (in this order): title, summary, description, author

  -e: print only articles w/ enclosures
  -n digit: number of articles to print
  -x: print xml
  -m: print only meta
*/

'use strict';

let path = require('path')

let minimist = require('minimist')

let feed = require('../lib/feed')

let errx = function(msg) {
    console.error(path.basename(process.argv[1]) + " error: " + msg)
    process.exit(1)
}

Array.prototype.toString = function() {
    return this.join(", ")
}

class MyGrep extends feed.Grep {

    event_fp_error(err) {
	let msg = err.message
	if (this.opts.debug) msg += "\n" + err.stack
	let prefix = "feedparser: "
	if (err instanceof feed.GrepError) prefix = ""
	errx(`${prefix}${msg}`)
    }

    print_meta(data) {
	let r = []
	for (let key in data) {
	    if (data[key]) r.push(`${key}: ${data[key]}`)
	}
	let encl = this.encl_stat()
	if (encl.total)
	    r.push(`enclosures: ${encl.total}/${encl.articles}/${this.articles.length}`)
	r.push("")
	this.push(r.join("\n"))
    }

    print_article(article) {
	let r = []
	if (this._articles_matched > 1) r.push("")

	for (let key in article) {
	    if (!article[key]) continue
	    if (this._article_text_prop[key]) continue

	    if (key.match(/\.__text$/))
		this._article_text_prop[key.split(".")[0]] = true

	    r.push(`${key}: ${article[key]}`)
	}
	r.push("")
	this.push(r.join("\n"))
    }
}


// main

let argv = minimist(process.argv.slice(2),
		    { boolean: ['v', 'e', 'x', 'm', 'debug'],
		      string: ['d', 'c', 'n'] })
if (argv.debug) console.error(argv)

let mfp = argv.x ? new feed.MyGrepXML(argv) : new MyGrep(argv)

process.stdin.once("end", () => {
    mfp.fp.end()
    // w/o this stdout closes too early
    mfp.fp.emit("end")
})

process.stdin
    .pipe(mfp)
    .pipe(process.stdout)

mfp.event.once("end", () => {
    if (!argv.m && mfp._articles_matched === 0) process.exit(1)
    process.exit(0)
})
