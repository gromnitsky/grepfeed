#!/usr/bin/env node
/*
  filter by:

  -d [-]date[,date]
  -c categories

  by default (in this order): title, summary, description, author

  -e: print only articles w/ enclosures
  -n digit: number of articles to print
  -x: print xml
  -m: print only meta
*/

'use strict';

let path = require('path')

let feed = require('../lib/feed')
let XMLGrep = require('../lib/xmlgrep')
let u = require('../lib/u')

let errx = function(msg) {
    console.error(path.basename(process.argv[1]) + " error: " + msg)
    process.exit(1)
}

class MyGrep extends feed.Grep {
    to_s_rules(klass) {
	return {
	    "Array": function() { return this.join(", ") }
	}[klass]
    }

    handle_error(err) {
	let msg = err.message
	if (this.opts.debug) msg += "\n" + err.stack
	errx(msg)
    }

    meta(data) {
	let r = []
	for (let key in data) {
	    if (!this.is_printable(data[key])) continue
	    this.to_s_set_rules(data[key])
	    r.push(`${key}: ${data[key]}`)
	}
	r.push("")
	return r.join("\n")
    }

    article(article) {
	let r = []
	r.push("")

	for (let key in article) {
	    if (!this.is_printable(article[key])) continue

	    this.to_s_set_rules(article[key])
	    let val = article[key]

	    if (/^(summary|description)$/.test(key)) val = feed.html2text(val)
	    r.push(`${key}: ${val}`)
	}
	r.push("")
	return r.join("\n")
    }
}


// main

let argv = u.opts_parse(process.argv.slice(2))
if (argv.debug) console.error(argv)

let mfp = argv.x ? new XMLGrep(argv) : new MyGrep(argv)

// override Grep#footer() to check if anything was matched
let orig_footer = mfp.footer.bind(mfp)
mfp.footer = function() {
    if (orig_footer) orig_footer()
    if (!argv.m && this.articles_matched === 0) process.exitCode = 1
}

process.stdin.once("end", () => {
    mfp.fp.end()
})

process.stdin
    .pipe(mfp)
    .pipe(process.stdout)
