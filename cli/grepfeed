#!/usr/bin/env node

'use strict';

let fs = require('fs')
let path = require('path')

let FeedParser = require('feedparser')
let pump = require('pump')

let feed = require('../lib/feed')
let XMLGrep = require('../lib/xmlgrep')
let u = require('../lib/u')
let meta = require('../package.json')

let errx = function(msg) {
    console.error(path.basename(process.argv[1]) + " error: " + msg)
    process.exit(1)
}

class MyGrep extends feed.Grep {
    to_s_rules(klass) {
	return {
	    "Array": function() { return this.join(", ") }
	}[klass]
    }

    meta(data) {
	let r = []
	for (let key in data) {
	    if (!this.is_printable(data[key])) continue
	    this.to_s_set_rules(data[key])
	    r.push(`${key}: ${data[key]}`)
	}
	r.push("")
	return r.join("\n")
    }

    article(article) {
	let r = []
	r.push("")

	for (let key in article) {
	    if (!this.is_printable(article[key])) continue

	    this.to_s_set_rules(article[key])
	    let val = article[key]

	    if (/^(summary|description)$/.test(key)) val = feed.html2text(val)
	    if (!this.is_printable(val)) continue
	    r.push(`${key}: ${val}`)
	}
	r.push("")
	return r.join("\n")
    }
}


// main

let argv = u.opts_parse(process.argv.slice(2))
if (argv.debug) console.error(argv)
if (argv.h || argv.help) {
    process.stdout.write(fs.readFileSync(__dirname + '/usage.txt').toString())
    process.exit(0)
}
if (argv.V) {
    console.log(meta.version)
    process.exit(0)
}

let feedparser = new FeedParser()
let grep = argv.x ? new XMLGrep(argv) : new MyGrep(argv)

grep.on('finish', function() {
    if (!argv.m && this.articles_matched === 0) process.exitCode = 1
})

pump(process.stdin, feedparser, grep, process.stdout, err => {
    if (err && err.code !== 'EPIPE')
	errx(argv.debug ? err.stack : err.message)
})
