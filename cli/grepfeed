#!/usr/bin/env node
/*
  filter by:

  -d [-]date[,date]
  -c categories

  by default (in this order): title, summary, description, author

  -e: print only articles w/ enclosures
  -n digit: number of articles to print
  -x: print xml
  -m: print only meta
*/

'use strict';

let path = require('path')

let FeedParser = require('feedparser')
let pump = require('pump')

let feed = require('../lib/feed')
let XMLGrep = require('../lib/xmlgrep')
let u = require('../lib/u')

let errx = function(msg) {
    console.error(path.basename(process.argv[1]) + " error: " + msg)
    process.exit(1)
}

class MyGrep extends feed.Grep {
    to_s_rules(klass) {
	return {
	    "Array": function() { return this.join(", ") }
	}[klass]
    }

    meta(data) {
	let r = []
	for (let key in data) {
	    if (!this.is_printable(data[key])) continue
	    this.to_s_set_rules(data[key])
	    r.push(`${key}: ${data[key]}`)
	}
	r.push("")
	return r.join("\n")
    }

    article(article) {
	let r = []
	r.push("")

	for (let key in article) {
	    if (!this.is_printable(article[key])) continue

	    this.to_s_set_rules(article[key])
	    let val = article[key]

	    if (/^(summary|description)$/.test(key)) val = feed.html2text(val)
	    r.push(`${key}: ${val}`)
	}
	r.push("")
	return r.join("\n")
    }
}


// main

let argv = u.opts_parse(process.argv.slice(2))
if (argv.debug) console.error(argv)

let feedparser = new FeedParser()
let grep = argv.x ? new XMLGrep(argv) : new MyGrep(argv)

grep.on('finish', function() {
    if (!argv.m && this.articles_matched === 0) process.exitCode = 1
})

pump(process.stdin, feedparser, grep, process.stdout, err => {
    if (err) errx(argv.debug ? err.stack : err.message)
})
